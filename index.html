<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NLP Sandbox - Interactive Subtitles with Video Sync</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      color: white;
      margin-bottom: 30px;
      text-align: center;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
      margin-bottom: 20px;
    }

    .video-section {
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    video {
      width: 100%;
      display: block;
      background: #000;
    }

    .video-url-input {
      padding: 15px;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      gap: 10px;
    }

    .video-url-input input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }

    .video-url-input button {
      padding: 10px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    .video-url-input button:hover {
      background: #5568d3;
    }

    .video-url-input small {
      position: absolute;
      bottom: -20px;
      left: 15px;
      color: #999;
      font-size: 12px;
    }

    #youtube-container {
      width: 100%;
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
    }

    #youtube-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }

    .time-display {
      font-size: 14px;
      color: #6c757d;
      margin-bottom: 10px;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: #667eea;
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .subtitles-panel {
      background: white;
      border-radius: 12px;
      overflow-y: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      max-height: 500px;
    }

    .subtitle {
      padding: 12px;
      margin: 8px;
      background: #f8f9fa;
      border-radius: 8px;
      line-height: 1.6;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }

    .subtitle:hover {
      background: #e9ecef;
      transform: translateX(4px);
    }

    .subtitle.current {
      background: #e3f2fd;
      border-left-color: #667eea;
    }

    .word {
      display: inline-block;
      cursor: pointer;
      padding: 4px 6px;
      margin: 2px 1px;
      border-radius: 4px;
      transition: all 0.15s ease;
      user-select: none;
    }

    .word:hover {
      background-color: #fff3cd;
      transform: scale(1.05);
    }

    .word.playing {
      background-color: #ffeb3b;
      font-weight: bold;
      box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
    }

    .word.clicked {
      background-color: #4caf50;
      color: white;
    }

    .sidebar {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      max-height: 500px;
      overflow-y: auto;
    }

    .sidebar h3 {
      color: #333;
      margin-bottom: 15px;
      font-size: 16px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }

    .word-info {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 14px;
      border-left: 3px solid #667eea;
    }

    .word-info strong {
      display: block;
      color: #667eea;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .info-row {
      margin: 6px 0;
      color: #555;
    }

    .info-label {
      font-weight: 600;
      color: #333;
      width: 60px;
      display: inline-block;
    }

    .stats {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      color: #666;
    }

    .stats-row {
      margin: 6px 0;
    }

    #loading {
      text-align: center;
      padding: 40px;
      color: white;
      font-size: 18px;
    }

    #error {
      color: #d32f2f;
      padding: 20px;
      background-color: #ffebee;
      border-radius: 12px;
      display: none;
      margin-bottom: 20px;
    }

    .no-video-message {
      background: #fff3cd;
      color: #856404;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .tooltip {
      position: absolute;
      background: #333;
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 1000;
      max-width: 250px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      white-space: normal;
      line-height: 1.4;
      animation: slideUp 0.2s ease-out;
    }

    .tooltip::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 15px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid #333;
    }

    .tooltip-word {
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .tooltip-definition {
      display: block;
      margin: 4px 0;
    }

    .tooltip-pos {
      font-size: 11px;
      opacity: 0.8;
      margin-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.3);
      padding-top: 6px;
    }

    .tooltip-loading {
      font-style: italic;
      opacity: 0.8;
    }

    .tooltip-error {
      color: #ff6b6b;
      font-size: 12px;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }

      .sidebar {
        max-height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üì∫ Interactive Subtitles with Video Sync</h1>
    
    <div id="error"></div>

    <div id="loading">Loading subtitles...</div>

    <div id="content" style="display: none;">
      <div class="main-content">
        <!-- Video Player Section -->
        <div class="video-section">
          <div class="video-url-input">
            <input 
              type="text" 
              id="video-url-input" 
              placeholder="Paste YouTube URL (e.g., https://youtu.be/...) or video file URL"
            >
            <button onclick="loadVideoURL()">Load Video</button>
          </div>
          <div class="no-video-message" id="no-video-msg">
            ‚ö†Ô∏è No video loaded. Paste a YouTube link or video file URL above and click "Load Video".
          </div>
          <div id="youtube-container" style="display: none;"></div>
          <video id="video" controls style="display: none;">
            <source src="" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <div class="video-controls">
            <div class="time-display">
              <span id="current-time">0:00</span> / <span id="duration">0:00</span>
            </div>
            <div class="progress-bar" id="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
            </div>
          </div>
        </div>

        <!-- Subtitles Section -->
        <div class="subtitles-panel" id="subtitles"></div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <h3>Word Information</h3>
        <div id="word-details">
          <p style="color: #999; font-size: 14px;">Click a word to see details here.</p>
        </div>
        <div style="margin-top: 20px;">
          <h3>Statistics</h3>
          <div class="stats">
            <div class="stats-row"><strong id="total-words">0</strong> total words</div>
            <div class="stats-row"><strong id="total-sentences">0</strong> sentences</div>
            <div class="stats-row"><strong id="clicked-count">0</strong> words clicked</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**
     * Interactive Subtitle System with Video Synchronization
     * Reverse-engineering Language Reactor's core functionality
     */

    /**
     * Extract YouTube video ID from various URL formats
     */
    function extractYouTubeID(url) {
      // Formats: youtu.be/ID, youtube.com/watch?v=ID, youtube.com/embed/ID
      const patterns = [
        /youtu\.be\/([a-zA-Z0-9_-]{11})/,
        /youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
        /youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/
      ];
      
      for (let pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
      }
      return null;
    }

    /**
     * Load video from URL (YouTube or direct file)
     */
    function loadVideoURL() {
      const input = document.getElementById('video-url-input');
      const url = input.value.trim();
      
      if (!url) {
        alert('Please enter a video URL');
        return;
      }

      const youtubeID = extractYouTubeID(url);
      const video = document.getElementById('video');
      const youtubeContainer = document.getElementById('youtube-container');
      const noVideoMsg = document.getElementById('no-video-msg');

      if (youtubeID) {
        // YouTube video - use iframe
        console.log('Loading YouTube video:', youtubeID);
        youtubeContainer.innerHTML = `
          <iframe 
            src="https://www.youtube.com/embed/${youtubeID}?enablejsapi=1" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
            allowfullscreen>
          </iframe>
        `;
        youtubeContainer.style.display = 'block';
        video.style.display = 'none';
        noVideoMsg.style.display = 'none';
        
        // Note: YouTube iframe requires API for full sync
        alert('YouTube video loaded. Note: Video sync requires YouTube API (paused for now). Subtitles are fully interactive!');
      } else if (url.startsWith('http') || url.includes('.mp4') || url.includes('.webm')) {
        // Direct video file
        console.log('Loading video file:', url);
        video.src = url;
        video.style.display = 'block';
        youtubeContainer.style.display = 'none';
        noVideoMsg.style.display = 'none';
        
        alert('Video file loaded. Press play to test video sync!');
      } else {
        alert('Invalid URL. Please provide a YouTube link or direct video file URL (mp4, webm, etc.)');
      }
    }

    /**
     * Handle Enter key in URL input
     */
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('video-url-input');
      if (input) {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') loadVideoURL();
        });
      }
    });
    const state = {
      words: [],
      sentences: [],
      currentTime: 0,
      playingWord: null,
      clickedWords: new Set(),
      selectedWord: null,
      currentTooltip: null,
      tooltipTimeout: null
    };

    // Dictionary cache to avoid repeated API calls
    const dictionaryCache = {};

    /**
     * Decode HTML entities (e.g., &gt; ‚Üí >)
     */
    function decodeHTMLEntities(text) {
      const textarea = document.createElement('textarea');
      textarea.innerHTML = text;
      return textarea.value;
    }

    /**
     * Load precomputed subtitle data
     */
    async function loadSubtitles() {
      try {
        const response = await fetch('data/subs_precomputed.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        if (!data.words || data.words.length === 0) {
          throw new Error('No subtitle data found');
        }

        state.words = data.words;
        console.log(`Loaded ${state.words.length} words`);
        return data;
      } catch (error) {
        console.error('Failed to load subtitles:', error);
        showError('Failed to load subtitle data. Make sure data/subs_precomputed.json exists.');
        return null;
      }
    }

    /**
     * Group words by sentence_id
     */
    function groupBySentence(words) {
      const grouped = {};
      
      words.forEach(word => {
        const sentenceId = word.sentence_id;
        if (!grouped[sentenceId]) {
          grouped[sentenceId] = [];
        }
        grouped[sentenceId].push(word);
      });

      return Object.keys(grouped)
        .sort((a, b) => parseInt(a) - parseInt(b))
        .map(key => ({
          id: parseInt(key),
          words: grouped[key]
        }));
    }

    /**
     * Create a clickable word element with event handlers
     */
    function createWordElement(wordObj) {
      const span = document.createElement('span');
      span.className = 'word';
      span.textContent = decodeHTMLEntities(wordObj.word);
      
      // Store data attributes
      span.dataset.wordId = wordObj.word_id;
      span.dataset.word = wordObj.word;
      span.dataset.start = wordObj.start;
      span.dataset.end = wordObj.end;
      span.dataset.sentenceId = wordObj.sentence_id;

      // Mark as clicked if previously clicked
      if (state.clickedWords.has(wordObj.word_id)) {
        span.classList.add('clicked');
      }

      // Click handler
      span.addEventListener('click', (e) => {
        e.stopPropagation();
        selectWord(wordObj, span);
      });

      // Hover handler for dictionary lookup
      span.addEventListener('mouseenter', (e) => {
        clearTimeout(state.tooltipTimeout);
        state.tooltipTimeout = setTimeout(() => {
          fetchDictionary(wordObj.word, span);
        }, 300); // 300ms delay before showing tooltip
      });

      span.addEventListener('mouseleave', (e) => {
        clearTimeout(state.tooltipTimeout);
        hideTooltip();
      });

      return span;
    }

    /**
     * Fetch dictionary definition from dioco.io API
     */
    async function fetchDictionary(word, element) {
      // Check cache first
      if (dictionaryCache[word]) {
        showTooltip(word, dictionaryCache[word], element);
        return;
      }

      // Show loading state
      showTooltip(word, { loading: true }, element);

      try {
        // Query parameters for dioco.io
        const params = new URLSearchParams({
          form: word,
          lemma: '',
          sl: 'ko',        // Source language: Korean
          tl: 'en',        // Target language: English
          pos: 'NOUN',     // Default POS (could be enhanced with actual tagging)
          pow: 'n'         // Power level
        });

        const response = await fetch(
          `https://api-cdn-plus.dioco.io/base_dict_getHoverDict_8?${params}`
        );

        if (!response.ok) throw new Error('Dictionary API error');
        
        const data = await response.json();
        
        // Cache the result
        dictionaryCache[word] = data;
        
        // Show tooltip with definition
        showTooltip(word, data, element);

        // Report stats to dioco (analytics)
        navigator.sendBeacon('https://api.dioco.io/stats', JSON.stringify({
          word: word,
          timestamp: Date.now()
        }));

      } catch (error) {
        console.error('Dictionary lookup failed:', error);
        showTooltip(word, { error: true }, element);
      }
    }

    /**
     * Show tooltip with dictionary definition
     */
    function showTooltip(word, data, element) {
      // Hide previous tooltip
      hideTooltip();

      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip';
      tooltip.style.position = 'absolute';
      tooltip.style.pointerEvents = 'auto';

      // Build tooltip content
      if (data.loading) {
        tooltip.innerHTML = '<div class="tooltip-loading">Looking up...</div>';
      } else if (data.error) {
        tooltip.innerHTML = '<div class="tooltip-error">Definition not found</div>';
      } else {
        let content = `<span class="tooltip-word">${word}</span>`;
        
        if (data.definitions && data.definitions.length > 0) {
          // Show first definition
          const def = data.definitions[0];
          content += `<span class="tooltip-definition">${def.meaning || def}</span>`;
          
          if (data.definitions.length > 1) {
            content += `<span style="font-size: 11px; opacity: 0.7;">+${data.definitions.length - 1} more</span>`;
          }
        }
        
        if (data.pos) {
          content += `<span class="tooltip-pos">${data.pos.toUpperCase()}</span>`;
        }

        tooltip.innerHTML = content;
      }

      // Position tooltip above the word
      document.body.appendChild(tooltip);
      
      const rect = element.getBoundingClientRect();
      tooltip.style.left = (rect.left + rect.width / 2 - 60) + 'px';
      tooltip.style.top = (rect.top - tooltip.offsetHeight - 15) + 'px';

      state.currentTooltip = tooltip;
    }

    /**
     * Hide tooltip
     */
    function hideTooltip() {
      if (state.currentTooltip) {
        state.currentTooltip.remove();
        state.currentTooltip = null;
      }
    }

    /**
     * Handle word selection and display metadata
     */
    function selectWord(wordObj, element) {
      state.selectedWord = wordObj;
      state.clickedWords.add(wordObj.word_id);
      
      // Log to console
      console.log('Word clicked:', {
        word_id: wordObj.word_id,
        text: wordObj.word,
        start: wordObj.start,
        end: wordObj.end,
        sentence_id: wordObj.sentence_id
      });

      // Update UI
      document.querySelectorAll('.word').forEach(w => w.classList.remove('clicked'));
      element.classList.add('clicked');

      // Display word info
      displayWordInfo(wordObj);

      // Update stats
      updateStats();

      // Jump video to word if playing
      const video = document.getElementById('video');
      if (video && video.src && !video.paused) {
        video.currentTime = wordObj.start;
      }
    }

    /**
     * Display word information in sidebar
     */
    function displayWordInfo(wordObj) {
      const detailsDiv = document.getElementById('word-details');
      
      const html = `
        <div class="word-info">
          <strong>${decodeHTMLEntities(wordObj.word)}</strong>
          <div class="info-row">
            <span class="info-label">ID:</span> ${wordObj.word_id}
          </div>
          <div class="info-row">
            <span class="info-label">Time:</span> ${wordObj.start.toFixed(2)}s - ${wordObj.end.toFixed(2)}s
          </div>
          <div class="info-row">
            <span class="info-label">Sentence:</span> ${wordObj.sentence_id}
          </div>
          <div class="info-row">
            <span class="info-label">Duration:</span> ${(wordObj.end - wordObj.start).toFixed(2)}s
          </div>
        </div>
      `;
      
      detailsDiv.innerHTML = html;
    }

    /**
     * Update statistics display
     */
    function updateStats() {
      document.getElementById('total-words').textContent = state.words.length;
      document.getElementById('total-sentences').textContent = state.sentences.length;
      document.getElementById('clicked-count').textContent = state.clickedWords.size;
    }

    /**
     * Find and highlight the word that should be playing at current time
     */
    function updatePlayingWord(currentTime) {
      state.currentTime = currentTime;

      // Find word at current time
      const playingWord = state.words.find(
        w => currentTime >= w.start && currentTime < w.end
      );

      // Update playing word highlight
      document.querySelectorAll('.word.playing').forEach(w => w.classList.remove('playing'));
      
      if (playingWord) {
        const wordElements = document.querySelectorAll(
          `.word[data-word-id="${playingWord.word_id}"]`
        );
        wordElements.forEach(el => el.classList.add('playing'));
        state.playingWord = playingWord;
      }

      // Update current sentence highlight
      const currentSentence = state.sentences.find(
        s => s.words.some(w => w.start <= currentTime && w.end > currentTime)
      );

      document.querySelectorAll('.subtitle').forEach(el => {
        el.classList.remove('current');
      });

      if (currentSentence) {
        const sentenceEl = document.querySelector(
          `.subtitle[data-sentence-id="${currentSentence.id}"]`
        );
        if (sentenceEl) {
          sentenceEl.classList.add('current');
          // Smooth scroll
          sentenceEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    /**
     * Format time in MM:SS format
     */
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Render all subtitles into the DOM
     */
    function renderSubtitles() {
      const subtitlesDiv = document.getElementById('subtitles');
      subtitlesDiv.innerHTML = '';

      state.sentences.forEach(sentence => {
        const sentenceDiv = document.createElement('div');
        sentenceDiv.className = 'subtitle';
        sentenceDiv.dataset.sentenceId = sentence.id;
        
        // Click sentence to jump video
        sentenceDiv.addEventListener('click', (e) => {
          if (e.target.classList.contains('word')) return;
          const video = document.getElementById('video');
          if (video && video.src) {
            video.currentTime = sentence.words[0].start;
            video.play();
          }
        });

        // Add words
        sentence.words.forEach((wordObj, index) => {
          const wordEl = createWordElement(wordObj);
          sentenceDiv.appendChild(wordEl);

          // Add space between words (except after last word)
          if (index < sentence.words.length - 1) {
            sentenceDiv.appendChild(document.createTextNode(' '));
          }
        });

        subtitlesDiv.appendChild(sentenceDiv);
      });
    }

    /**
     * Setup video player event listeners
     */
    function setupVideoPlayer() {
      const video = document.getElementById('video');
      const progressBar = document.getElementById('progress-bar');
      const progressFill = document.getElementById('progress-fill');
      const currentTimeEl = document.getElementById('current-time');
      const durationEl = document.getElementById('duration');

      // Update time display and playing word
      video.addEventListener('timeupdate', () => {
        updatePlayingWord(video.currentTime);
        currentTimeEl.textContent = formatTime(video.currentTime);
        const progress = (video.currentTime / video.duration) * 100;
        progressFill.style.width = `${progress}%`;
      });

      // Update duration when loaded
      video.addEventListener('loadedmetadata', () => {
        durationEl.textContent = formatTime(video.duration);
      });

      // Progress bar click to seek
      progressBar.addEventListener('click', (e) => {
        const rect = progressBar.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        video.currentTime = percent * video.duration;
      });
    }

    /**
     * Show error message
     */
    function showError(message) {
      document.getElementById('loading').style.display = 'none';
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }

    /**
     * Main initialization
     */
    async function init() {
      const data = await loadSubtitles();
      if (!data) return;

      // Group words by sentence
      state.sentences = groupBySentence(data.words);

      // Render subtitles
      renderSubtitles();

      // Setup video player
      setupVideoPlayer();

      // Update stats
      updateStats();

      // Show content
      document.getElementById('loading').style.display = 'none';
      document.getElementById('content').style.display = 'grid';

      console.log(`‚úÖ Loaded ${state.words.length} words across ${state.sentences.length} sentences`);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
  
  <!-- Language Reactor-style Dictionary Module -->
  <script src="subtitle-dictionary.js"></script>
</body>
</html>
